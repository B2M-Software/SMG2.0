/*
 * Copyright (c) 2011-2015, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution.
 */
package org.fortiss.smg.actuatorclient.sunny.test;import java.util.ArrayList;import java.util.Random;import java.util.concurrent.TimeoutException;import org.fortiss.smg.actuatormaster.api.AbstractClient;import org.fortiss.smg.actuatormaster.api.IActuatorClient;import org.fortiss.smg.actuatormaster.api.events.DoubleEvent;import org.fortiss.smg.containermanager.api.devices.DeviceId;import org.fortiss.smg.smgschemas.commands.DoubleCommand;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import ch.qos.logback.classic.LoggerContext;import ch.qos.logback.classic.encoder.PatternLayoutEncoder;import ch.qos.logback.core.ConsoleAppender;public class DummyEventPusher extends AbstractClient implements IActuatorClient {	// Logger from sl4j	private static org.slf4j.Logger logger = LoggerFactory			.getLogger(DummyEventPusher.class);	private ArrayList<String> wrappers;		String 		queue = "awesome-abstract-client-dummy";	// in s	int timeout = 5;	public static void main(String[] args) {		// BasicConfigurator.configure();		LoggerContext logCtx = (LoggerContext) LoggerFactory.getILoggerFactory();		PatternLayoutEncoder logEncoder = new PatternLayoutEncoder();		logEncoder.setContext(logCtx);		logEncoder				.setPattern("%-12date{YYYY-MM-dd HH:mm:ss.SSS} %-5level - %msg%n");		logEncoder.start();		ConsoleAppender logConsoleAppender = new ConsoleAppender();		logConsoleAppender.setContext(logCtx);		logConsoleAppender.setName("console");		logConsoleAppender.setEncoder(logEncoder);		logConsoleAppender.start();		// add appender to any Logger (here is root)		LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);		try {			new DummyEventPusher().start();		} catch (InterruptedException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}	}	private void start() throws InterruptedException {		// Register at Actuator Master (self, human readable name for device)		registerAsClientAtServer(this, queue, new IOnConnectListener() {						@Override			public void onSuccessFullConnection() {				try {					sendLoop();				} catch (InterruptedException e) {					// TODO Auto-generated catch block					e.printStackTrace();				}			}		});			}		private void sendLoop() throws InterruptedException{		logger.debug("Pushing dummy events started");		Random rnd = new Random();		while (true) {			DoubleEvent ev = new DoubleEvent(rnd.nextInt(10000) * 0.01);			DeviceId dev = new DeviceId("mocked-dev", "non-existing-wrapper");			try {				master.sendDoubleEvent(ev, dev, queue);			} catch (TimeoutException e) {				// refresh master				logger.debug("--- TIMEOUT ---");				registerAsClientAtServer(this, queue,  new IOnConnectListener() {										@Override					public void onSuccessFullConnection() {						// TODO Auto-generated method stub											}				});			}			Thread.sleep(timeout * 1000);		}	}	@Override	public boolean isComponentAlive() throws TimeoutException {		// TODO Auto-generated method stub		return false;	}	@Override	public void onDoubleCommand(DoubleCommand command, DeviceId dev) {		// TODO Auto-generated method stub	}}