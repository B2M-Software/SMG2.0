package org.fortiss.smg.actuatorclient.arduino.impl;import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.concurrent.TimeoutException;import org.fortiss.smg.actuatorclient.arduino.impl.models.beans.Subdevice;import org.fortiss.smg.actuatormaster.api.AbstractClient;import org.fortiss.smg.actuatormaster.api.ActuatorMasterQueueNames;import org.fortiss.smg.actuatormaster.api.IActuatorMaster;import org.fortiss.smg.config.lib.WrapperConfig;import org.fortiss.smg.remoteframework.lib.DefaultProxy;import org.osgi.framework.BundleActivator;import org.osgi.framework.BundleContext;import org.slf4j.LoggerFactory;public class ActuatorClientActivator extends AbstractClient implements BundleActivator {	ActuatorClientImpl impl;		private List<ActuatorClientImpl> clients = new ArrayList<ActuatorClientImpl>();	IActuatorMaster master4config = null;    	// Logger from sl4j    private static org.slf4j.Logger logger = LoggerFactory.getLogger(ActuatorClientActivator.class);    @Override    public void start(BundleContext context) throws Exception {        // register here your services etc.        // DO NOT start heavy operations here - use threads    			ArrayList<WrapperConfig> configList = new ArrayList<WrapperConfig>();		DefaultProxy<IActuatorMaster> proxyMaster = new DefaultProxy<IActuatorMaster>(				IActuatorMaster.class,				ActuatorMasterQueueNames.getActuatorMasterInterfaceQueue(),				5000);		try {			master4config = proxyMaster.init();		} catch (TimeoutException e) {			logger.error("ActuatorClient: Unable to connect to master (Timeout).");		}				/*		 * If we have connection try to get the wrapper's config file		 */		if (master4config != null) {			try {				configList = master4config.getWrapperConfig("arduino");			} catch (TimeoutException e) {				logger.error("ActuatorClient: Unable to connect to master (Timeout).");			} finally {				try {					proxyMaster.destroy();				} catch (IOException e) {					logger.info("Unable to close con. for queue:"							+ this.clientId);				}			}			/*			 * For each received wrapper config instance (possibly the same			 * wrapper is used for multiple (physical) devices			 */						if (configList == null) {				System.out.println("=============== List is NULL =================");			}						for (WrapperConfig config : configList) {								if (config == null) {					System.out.println("=============== Config is NULL =================");				}								System.out.println("=============== WORKS =================");								ArduinoConfig arduinoConfig = new ArduinoConfig();				arduinoConfig.setWrapper_id(config.getWrapperID());				arduinoConfig.setWrapper_name(config.getWrapperName());				arduinoConfig.setProtocol(config.getProtocol());				arduinoConfig.setHost(config.getHost());				arduinoConfig.setPort(config.getPort());				arduinoConfig.setPolling_frequency(config.getPollingfrequency());				ArrayList<Subdevice> subdevices = new ArrayList<Subdevice>();				for (int i = 0; i < config.getSubdevices().size(); i++) {					Subdevice subdevice = new Subdevice();					subdevice.setDeviceCode(config.getSubdevices().get(i).getDeviceCode());					subdevice.setThreshold(config.getSubdevices().get(i).getThreshold());					subdevice.setPin(config.getSubdevices().get(i).getPin());					subdevices.add(subdevice);				}				arduinoConfig.setSubdevices(subdevices);				// TODO - add subdevcies!!!				System.out.println("============================================");				System.out.println(config.getWrapperID());				System.out.println(config.getWrapperName());				System.out.println(config.getProtocol());				System.out.println(config.getHost());				System.out.println(config.getPort());				System.out.println(config.getPollingfrequency());				for (int i = 0; i < config.getSubdevices().size(); i++) {					System.out.println("This is a subdevice: " + config.getSubdevices().get(i).getDeviceCode());					System.out.println("This is a threshold: " + config.getSubdevices().get(i).getThreshold());					System.out.println("This is a pin: " + config.getSubdevices().get(i).getPin());				}				System.out.println("============================================");								impl = new ActuatorClientImpl(arduinoConfig);								// Register at Actuator Master (self, human readable name for				// device)				registerAsClientAtServer(impl, config.getWrapperName(),						new IOnConnectListener() {							@Override							public void onSuccessFullConnection() {								// When we call registerAsClientAtServer, it will first call __registerClientAtServer() method from the								// AbstractClient, and then this method will check whether the client is registered to the activator master								// If our client is not registered, then the AtivatorMaster will register our device and give us back id								// clientId and master are available from the AbstractClient class								impl.setClientId(clientId);								impl.setActuatorMaster(master);								// This method will start sending data from the devices to the actuator master								impl.activate();								logger.info("ActuatorClient - Arduino is started");																clients.add(impl);							}						});			}		} else {			proxyMaster.destroy();			logger.debug("Arduino Wrapper could not read config from Master");			this.stop(context);		}    }    @Override    public void stop(BundleContext context) throws Exception {        // REMEMBER to destroy all resources, threads and do cleanup        impl.destroy();        this.destroy();        logger.info("ActuatorClient - Arduino is stopped");    }}